apply from: "$rootDir/gradle/base.gradle"

import com.xlson.groovycsv.CsvParser
import java.time.*
import java.time.format.DateTimeFormatter

// TODO find a way to general import buildscript deps...
buildscript {
	dependencies {
		classpath fileTree("$rootDir/gradle/lib").include("**.jar")
	}
}

///////  Configuration

ext {
	// The Harvest server configuration
	harvest = [
		// The harvest broker name.
		broker: null,
		
		// The harvest project name.
		project: null,
		
		// The harvest viewpath.
		viewpath: null,

		// The harvest state.
		state: null
	]
	
	// The git bridge configuration, override in used project
	gitbridge = [
		// The store that holds meta data about harvest, e.g. the last fetched date and version.
		datadir: null,
		
		// The root directory of the git repository.
		gitroot: null
	]

	formats = [
		US_DATE: DateTimeFormatter.ofPattern("MM/dd/yyyy"),
		HARVEST: DateTimeFormatter.ofPattern("MM-dd-yyyy;HH:mm:ss"),
		GIT_COMMIT: DateTimeFormatter.ofPattern("MM/dd/yyyy'T'HH:mm:ss")
	]
}

///////  Updating the Git repository

/** Converts Harvest viewpath to platform-specific local path. */
def toLocalPath = { viewpath ->
	def result = viewpath.replace("\\" + harvest.viewpath, gitbridge.gitroot)
	return result.replaceAll("[\\\\/]", Matcher.quoteReplacement(File.sep‌​arator))
}

/**
 * Returns the array to execute the given harvest CLI command. Handles login based on the configured harvest options.
 */
def getHarvestCommand = { tool ->
	def command = [ tool, "-b", harvest.broker, "-en", harvest.project, "-o", "${gitbridge.datadir}/${tool}.log" ]
	if (harvest.state) {
		command += ["-st", harvest.state]
	} 
	if (harvest.user && harvest.password) {
		command += ["-usr", harvest.user]
		command += ["-pw", harvest.password]
	} else {
		command += ["-prompt"]
	}
	return command
}

/** Checks out the given version of the given file from Harvest. */
def checkoutVersion = { fileEntry ->
	def options = [ workingDir: gitbridge.gitroot ]
	def command = getHarvestCommand("hco")
	command += [ "-vp", fileEntry.Path, "-cp", toLocalPath(fileEntry.Path), "-s", fileEntry.Name, "-vn", fileEntry.Version, "-br", "-r" ]
	shell(options, command)
}

/**
 * Fetches version information using the hsv command. Returns the result as a string.
 */
def fetchVersions = { lastFetch, currentFetch ->
	def options = [ workingDir: gitbridge.datadir ]
	def command = getHarvestCommand("hsv")
	def from = LocalDateTime.ofEpochSecond(lastFetch.intdiv(1000), 1000 * (lastFetch % 1000) as Integer, ZoneOffset.UTC).format(formats.US_DATE)
	def to = LocalDateTime.ofEpochSecond(currentFetch.intdiv(1000), 1000 * (currentFetch % 1000) as Integer, ZoneOffset.UTC).plusDays(1).format(formats.US_DATE)

	def hsvOutputFile = file("${gitbridge.datadir}/hsv.log")
	if(hsvOutputFile.exists()) {
		hsvOutputFile.delete()
	}

	command += [ "-vp", harvest.viewpath, "-s", "*", "-iv", "av", "-id", "sd", from, to]
	shell(options, command)

	assert hsvOutputFile.exists()
	def hsvOutputLines = hsvOutputFile.readLines()
	
	if (hsvOutputLines.size() < 4) {
		return ""
	}

	hsvOutputLines.remove(2)
	hsvOutputLines.remove(0)
	return hsvOutputLines.dropRight(2).join("\n")
}

/** Converts the given time string from Harvest's hsv output format to git commit format. */
def convertTimestamp = {
	return LocalDateTime.parse(it, formats.HARVEST).format(formats.GIT_COMMIT)
}

/** 
 * Stages all changes in gitbridge.gitroot and commits them with the given
 * author, message, and commit time.
 */
def commit = { author, message, time ->
	def options = [ environment: ["GIT_COMMITTER_DATE": time ], workingDir: gitbridge.gitroot ]
	println shell(options, ["git", "add", "."])
	println shell(options, ["git", "commit", "--allow-empty", "--date=$time", "--author=\"$author\"", "-m", message])
}

/**
 * Initializes the git repository. Sets default committer and adds a .gitignore file
 * that prevents harvest signature files from being added to the repository.
 */
def initRepository = {
	println "${gitbridge.gitroot} does not seem to be a Git repository. Initializing."

	def options = [ environment: ["GIT_COMMITTER_DATE": "01/01/2015'T'00:00:00" ], workingDir: gitbridge.gitroot ]
	shell(options, ["git", "init"])
	shell(options, ["git", "config", "user.name", "CQSE Harvest Git Bridge"])
	shell(options, ["git", "config", "user.email", "nobody@nomail.com"])
	file("${gitbridge.gitroot}/.gitignore").write "harvest.sig\n"
	shell(options, ["git", "add", ".gitignore"])
	shell(options, ["git", "commit", "--date=01/01/2015'T'00:00:00", "-m", "Ignore Harvest Signatures"])
}

/**
 * Processes all file entries for a group of changes that belong to the same minute.
 * Entries with the "D" tag are removed from the repository, for all other entries we
 * checkout the provided version. The return value is a set of all individual change
 * times that were processed.
 */
def processFileEntries = { entries ->
	def processedTimes = [] as Set
	for(fileEntry in entries.sort{ LocalDateTime.parse(it.Modified, formats.HARVEST) }) {
		switch(fileEntry.Tag) {
			case "D":
				file(toLocalPath(fileEntry.Path + "/" + fileEntry.Name)).delete()
				break
			case "N":
				checkoutVersion(fileEntry)
				break
		}
		// In any case, mark the change as processed
		processedTimes.add(fileEntry.Modified)
	}
	return processedTimes
}

/**
 * Main task. Checks Harvest for new changes, groups them into git commits and 
 * applies them to the git repository.
 */
task updateGit {
	doLast {
		assert harvest.broker != null
		assert file(gitbridge.datadir).exists()
		assert file(gitbridge.gitroot).exists()

		def gitFolder = file("${gitbridge.gitroot}/.git")
		if(!gitFolder.exists()) {
			initRepository();
		}

		def authorMappingFile = file("${gitbridge.datadir}/authors.properties")
		def authorMapping = new Properties()
		if(authorMappingFile.exists() && authorMappingFile.canRead()) {
			authorMapping.load(authorMappingFile.newReader())
		} else {
			println "No author mapping file found. Using defaults."
		}
		
		def commitsFile = file("${gitbridge.datadir}/processedCommits.txt")
		def processedCommits = (commitsFile.exists() ? commitsFile.readLines() : []) as Set
		
		def timestampFile = file("${gitbridge.datadir}/timestamp.txt")
		def lastFetch = Long.valueOf(timestampFile.exists() ? timestampFile.readLines()[0] : 0)
		def currentFetch = System.currentTimeMillis();

		def hsvOutput = fetchVersions(lastFetch, currentFetch)

		// Contains (among others): Name, Path, Version, Package, Modifier, Modified
		def changes = CsvParser.parseCsv( hsvOutput, separator: '\t', escapeChar: '\0' )

		// Ignore the ones that we already have or that are not tagged D or N.
		changes = changes.findAll( { (it.Tag == "N" || it.Tag == "D") && !processedCommits.contains(it.Modified) } )

		// group by time (truncated to full minutes), package, and author
		def groupedChanges = changes.groupBy{ [ time: it.Modified.take(17) + "00", package: it.Package, author: it.Modifier] }

		// sort by timestamp
		groupedChanges = groupedChanges.sort{ LocalDateTime.parse(it.key.time, formats.HARVEST) }

		println "Found ${groupedChanges.size()} unprocessed changes."

		for(change in groupedChanges) {
			def gitAuthor = authorMapping[change.key.author]
			if(gitAuthor == null) {
				gitAuthor = "${change.key.author} <${change.key.author}@nomail>"
			}

			def processedTimes = processFileEntries(change.value)
			commit(gitAuthor, change.key.package, convertTimestamp(change.key.time))
			commitsFile.withWriterAppend { out -> processedTimes.toSorted().each { out.println it } }
		}
		timestampFile.write "${currentFetch}"

		println "Done."
	}
}

