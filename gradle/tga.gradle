apply from: "$rootDir/gradle/base.gradle"

// TODO find a way to general import buildscript deps...
buildscript {
	dependencies {
		classpath fileTree("$rootDir/gradle/lib").include("**.jar")
	}
}

///////  Configuration

ext {
	// The Teamscale server configuration
	teamscale = [
		// The Teamscale server URL
		url: "http://localhost:8080",
		
		// The user uploads are performed with. 
		username: "admin",
		
		// The user access token. Must be set!. Gather from Teamscale Web UI, password will not work!
		// FIXME rename to accesskey
		password: null,
		
		// The project id. Must be set!
		project: null,
		
		// Configuration of HTTP Timeouts
		timeout: [
			connect: 60,
			write: 60,
			read: 60
		]
	]
	
	// Dry run will prevent submitting data to Teamscale
	dryRun = false
	
	// The TGA configuration, override in used project
	tga = [
		// .NET debugging file (PDB) configuration
		pdb: [
			// The PDB inbox, usually the build drop location.
			inbox: [
				// A directory that is scanned for (new) subdirectories which correlate to new builds.
				// May be null in order to disable inbox and work on manual created store.
				dir: null,

				// An optional check that is performed before copying files to the store from the inbox. If false, copying will be skipped. 
 				require: { dir -> true },			
				
				// Included files, usually just PDB files.
				includes: ["**/*.pdb"],
				
				// Optional excluded PDBs.
				excludes: [],
				
				// Allows further filtering of included files, e.g. by size.
				filter: { file -> true },
				
				// Closure that returns the version based on the build directory
				version: { path -> file(path).name },

				// Whether the files should be copied flat or in an hierarchical structure
				copyFlat: false,
			],
			
			// The PDB store. Usually the store gets filled from the inbox.
			// It requires (unless otherwise configured) subfolders that correspond to "versions" of PDBs that are published in teamscale.
			store: [
				// The store location. Must be set in implementing project.
				dir: null,
				
				// Included files, usually just PDB files.
				includes: ["**/*.pdb"],
				
				// Optional excluded PDBs.
				excludes: [],
				
				// Allows further filtering of included files, e.g. by size. Usually this is not needed and filtering should be applied before copying to the store.
				filter: { file -> true },
				 
				// Closure that returns the program version based on the build directory. Usually there is no need to configure this property.
				version: { dir -> file(dir).name }
			],
			
			// The amount of pdb files to upload in one batch
			uploadCollate: 8,
			
			// The PDB file that is used to calculate the timestamp the PDBs correlate to the code (approximation), better override timestamp closure and extract exact revision.
			// FIXME, move to store/inbox?
			timestampFile: null,

			// Defines the branch for the uploaded timestamp (currently not working)
			timestampBranch: { path -> null },
			
			// The timestamp calculation closure. Timestamp the PDB files correspond to in the repository.
			// Defaults to the modification timestamp of a specific file in build output, override if better means exist.
			timestamp:  { path ->
				assert tga.pdb.timestampFile != null
				def timestampFile = file("${path}/${tga.pdb.timestampFile}")
				assert timestampFile.exists()
				def ts = timestampFile.lastModified() as long
				def branch = tga.pdb.timestampBranch(path)
				if (branch != null) {
					ts = "$branch:$ts"
				}
				return ts
			}
		],
		
		trace: [
			// E.g. file share where traces are copied after test execution (dir may be null to disable inbox and work on store directly, this is however not recommended)
			inbox: [
				// The trace inbox location.
				dir: null,
				
				// The trace include pattern, defaults to txt files.
				includes: ["*.txt"],
				
				// Optional file pattern excludes.
				excludes: [],
				
				// Optional further filtering.
				filter: { file -> true }
			],
			
			// Directory where unprocessed traces are located. If a inbox is defined, the traces are moved from the inbox into this folder.
			store: [
				// The trace store location.
				dir: null,
				
				// The trace include pattern, defaults to txt files.
				includes: ["*.txt"],
				
				// Optional file pattern excludes.
				excludes: [],
				
				// Optional further filtering.
				filter: { file -> true },
				
				// A closure that calculates the timestamp of when the trace was created (default: modification date).
				timestamp: { file -> file.lastModified() },
				
				// An assmebly that is used to detect the program version from the trace file.
				versionAssembly: null,
				
				// Version attribute that is extracted from the trace file
				versionAttribute: "Version",

				// Closure that returns the program version a trace corresponds to. Return null to ignore trace. Defaults to a version assembly. 
				version: { file ->
					assert tga.trace.store.versionAssembly != null
					
					def assemblyKey = "Assembly=$tga.trace.store.versionAssembly:"
					def assemblyLine = file.readLines().find { it.startsWith(assemblyKey) }
					if (assemblyLine == null) {
						return null
					}
					assemblyLine -= assemblyKey
					assemblyLine.split(" ").find{it.startsWith(tga.trace.store.versionAttribute+":")}.split(":")[1]
				}
			],
			
			// Directory where traces are archived (in a subfolder corresponding to the version)
			archive: [ dir: null ]
		]
	]
}

///////  Trace Handling

task collectPdb {
	doLast {
		if (tga.pdb.inbox.dir == null) {
			println "No PDB inbox defined, skipping"
			return;
		}
		
		assert file(tga.pdb.inbox.dir).exists()
		
		def stored = file("${tga.pdb.store.dir}/stored.txt")
		def storedDirs = (stored.exists() ? stored.readLines() : []) as Set
		
		file(tga.pdb.inbox.dir).eachDir { inboxDir ->
			if (storedDirs.contains(inboxDir.name)) {
				return
			}
			
			println "Storing PDBs from $inboxDir.name"
			
			if (!tga.pdb.inbox.require(inboxDir)) {
				println "  -> Skipping, due to missing requirement"
				return
			}
			
			def version = tga.pdb.inbox.version(inboxDir)
			println "  ... for version $version"
			
			def store = "$tga.pdb.store.dir/$version"

			fileTreeFiltered(inboxDir, tga.pdb.inbox).files.each { file ->
				def toDir = store
				if (!tga.pdb.inbox.copyFlat) {
					toDir += "/" + (file.parent - inboxDir)
				}
				ant.copy(file: file, toDir: toDir, preservelastmodified: true)
			}
			
			stored.append "$inboxDir.name\r\n"
		}
	}
}

task uploadPdb(dependsOn: collectPdb) {
	doLast {
		assert file(tga.pdb.store.dir).exists()
		assert teamscale.project != null
		
		def published = file("${tga.pdb.store.dir}/published.txt")
		def publishedVersions = (published.exists() ? published.readLines() : []) as Set
		
		def dirs = [:]
		file(tga.pdb.store.dir).eachDir { pdbDir ->
			def version = tga.pdb.store.version(pdbDir)
			if (publishedVersions.contains(version)) {
				return
			}
		
			def timestamp = tga.pdb.timestamp(pdbDir)
			dirs.put(timestamp, [version, pdbDir])
		}

		dirs.keySet().sort().each { timestamp ->
		 	def (version, pdbDir) = dirs[timestamp]
					
			println "Uploading PDBs to $teamscale.project"
			println "  ... for timestamp $timestamp"
			println "  ... for version $version"
			if (dryRun) {
				println "  ... in DRY-RUN mode"
			}
			
			def http = createHttpClient(teamscale)
			def pdbs = fileTreeFiltered(pdbDir, tga.pdb.store)
			pdbs.collate(tga.pdb.uploadCollate).each { pdbSlice ->
				println "  -> Uploading: " + pdbSlice
				
				if (dryRun) {
					return
				}
			
				println http.post(String) {
					request.uri.path = "/p/${teamscale.project}/dotnet-debug-info-upload"
					request.contentType = 'multipart/form-data'
					request.uri.query = [
						t: timestamp,
						version: version
					]
					request.body = groovyx.net.http.MultipartContent.multipart {
						pdbSlice.each {
							part 'file', it.name, 'text/plain', it
						}
					}
					request.encoder 'multipart/form-data', groovyx.net.http.OkHttpEncoders.&multipart
				}
			}
			
			published.append "${version}\r\n"
		}
	}
}

///////  Trace Handling

task collectTraces {
	doLast {
		if (tga.trace.inbox.dir == null) {
			println "No Trace inbox defined, skipping"
			return
		}
		
		assert file(tga.trace.store.dir).exists()
		
		fileTreeFiltered(tga.trace.inbox.dir, tga.trace.inbox).files.each { traceFile ->
			ant.move(file: traceFile, toDir: tga.trace.store.dir, preservelastmodified: true, failonerror: false)
		}
	}
}

task uploadTrace(dependsOn: collectTraces) {
	doLast {
		assert file(tga.trace.store.dir).exists()
		assert file(tga.trace.archive.dir).exists()
		
		def http = createHttpClient(teamscale)
		def sortedTraces = fileTreeFiltered(tga.trace.store.dir, tga.trace.store).files.sort{ it.lastModified() }
		println "Uploading Traces to project $teamscale.project"
		sortedTraces.each { traceFile ->
			def timestamp = tga.trace.store.timestamp(traceFile)
			def version = tga.trace.store.version(traceFile)
			
			println "  -> $traceFile.name"
			println "     ... for timestamp $timestamp"
			println "     ... for version $version"
			if (dryRun) {
				println "     ... in DRY-RUN mode"
			}
			
			if (dryRun) {
				return
			}
			
			if (version == null) {
				ant.move(file: traceFile, todir: "$tga.trace.archive.dir/_unknown", preservelastmodified: true)
				println "     -> Skipped due to missing version"
				return
			}
			
			println http.post(String) {
			    request.uri.path = "/p/${teamscale.project}/dotnet-ephemeral-trace-upload"
			    request.contentType = 'multipart/form-data'
			    request.uri.query = [
				    t: timestamp,
				    version: version,
				    adjusttimestamp: true,
				    message: "Manual Test (from trace ${traceFile.name})",
				    partition: "Manual Test"
			    ]
			    request.body = groovyx.net.http.MultipartContent.multipart {
				    part 'report', traceFile.name, 'text/plain', traceFile
			    }
			    request.encoder 'multipart/form-data', groovyx.net.http.OkHttpEncoders.&multipart
		   	}
			
			ant.move(file: traceFile, todir: "$tga.trace.archive.dir/$version", preservelastmodified: true)
		}
	
	}
}

def createHttpClient(teamscale) {
	assert teamscale.password != null
	
	return groovyx.net.http.OkHttpBuilder.configure {
		request.uri = teamscale.url
		//request.auth.basic teamscale.username, teamscale.password
		request.headers['Authorization'] = "Basic " + "${teamscale.username}:${teamscale.password}".bytes.encodeBase64().toString()
		
		clientConfig.clientCustomizer { okhttp3.OkHttpClient.Builder builder ->
			builder.connectTimeout(teamscale.timeout.connect, java.util.concurrent.TimeUnit.SECONDS);
			builder.writeTimeout(teamscale.timeout.write, java.util.concurrent.TimeUnit.SECONDS);
			builder.readTimeout(teamscale.timeout.read, java.util.concurrent.TimeUnit.SECONDS);
		}
	}
}
